# EventLoop机制

**JS是单线程语言，而浏览器是多线程**
> 单线程和多线程最简单的区别就是：
> 单线程*同一时间*只能做一件事情；
> 多线程*同一时间*能做多件事情。

## 任务队列
JS将所有执行任务分为了同步任务和异步任务。   

其实，每个人物都是在做两件事：发起调用 和 得到结果。

同步任务和异步任务最大的区别就是，同步任务在发起调用后立即得到结果。这是因为同步任务和异步任务的执行机制不同导致的。

同步任务按照代码顺序和调用顺序，依次进入调用栈（Call Stack）并执行，执行结束后从调用栈移除。  
异步任务也一样进入调用栈，然后发起调用，解释器会将其相应回调任务放入任务队列，之后从调用栈移除。当主线程清空后，即所有同步任务结束后，解释器会读取任务队列，并将已完成的异步任务加入调用栈中并执行。

```js
console.log(1);

fetch("https://github.com/Lynn0221/")
  .then(response => response.json())
  .then(json => console.log(json))

console.log(2);
```
上述代码：  
1. 执行`console.log(1)`，打印1
2. 调用fetch()发起请求，此时`.then()`已经在任务队列，fetch()移除调用栈
3. 执行`console.log(2)`，打印2
4. 将任务队列里`.then()`依次进入调用栈执行

## 宏任务微任务
任务队列遵循FIFO（先进先出），因此异步任务会按照进入队列的顺序依次执行。  
但在一些场景下，如果只按照进入队列的顺序依次执行的话，也会出问题。如果队列进入一个1小时的定时器，接着在进入一个请求接口函数，而如果根据进入队列的顺序执行的话，请求接口函数需要一个小时后才会响应数据。  
因此浏览器就会将异步任务分为宏任务和微任务，然后按照 **事件循环** 的机制去执行。
哪些事件是宏任务？哪些是微任务？
宏任务：整体代码，UI交互式事件，IO，setTimeout，setInterval，setImmediate，requestAnimationFrame
微任务：process.nextTick，Object.observe，MutationObserve，Promise.then catch finally

## 事件循环

### 浏览器的事件循环

事件循环的流程如下：
1. 当我们第一次执行的时候，解释器会将整体代码script放入宏任务队列中，因此事件循环时从第一个宏任务开始的
2. 从宏任务队列中，按照入队顺序，找到第一个执行的宏任务，放入调用栈，开始执行
3. 执行完该宏任务下所有同步任务后，该宏任务被推出宏任务队列，然后微任务队列开始按照入队顺序依次执行其中的微任务，直至微任务队列清空
4. 当微任务队列清空后，一个事件循环结束
5. 接着从宏任务队列，找到下一个执行的宏任务，开始第二个事件循环，以此类推...

根据代码具体看一下执行过程：
```js
console.log("a");

// 为了说明和延迟时间无关，将延迟设为 0
setTimeout(() => {
  console.log("b")
}, 0);

new Promise((resolve) => {
  console.log("c");
  resolve();
}).then(() => {
  console.log("d")
}).then(() => {
  console.log("e")
})

console.log("f"); // a c f d e b
```
首先，整体代码 script 被推入宏任务队列汇总，并开始执行宏任务。

按照代码顺序，将`console.log("a")`该函数上下文被推入调用栈，执行完后，即移除调用栈。
**-> 输出 a**

接下来，将`setTimeout()`函数上下文也进入调用栈中，`setTimeout`是异步任务，将其`callback`函数推入红任务队列中，然后该函数被移除调用栈。

接着`Promise`语句被放入调用栈，执行`console.log("c")` 和 `resolve()`。`.then()`是微任务，将其依次放入微任务队列。将`Promise`移除调用栈。
**-> 输出 c**

接着再将`console.log("f")`放入调用栈并执行
**-> 输出 f**

此时`script`宏任务执行结束，被推出宏任务队列。

检测到微任务队列里还有任务没有完成，依次将其放入调用栈执行.`.then(()=>{ console.log("d") })` **-> 输出 d**，移除调用栈。第二个`then()`函数放入调用栈执行 **-> 输出 e**，移除调用栈。

到此，微任务队列也已经清空了，第一个事件循环已经结束。

接着来到第二个事件循环,`setTimeout()`的`callback`
**-> 输出 b**

执行结束后，它也被移除宏任务队列和调用栈。此时，微任务队列里也没有任务，因此第二个事件循环结束。宏任务队列也没有任务，所有代码执行结束。


## 参考 
[Event Loop机制到底是个啥](https://segmentfault.com/a/1190000022060158)

[搞懂EventLoop机制](https://www.jianshu.com/p/58e11dc2e2e7)
